<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-8000</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>DEFAULT_PORT = 38181;
SOCKET_TYPE = network_socket_udp;

/// packet types
enum PTYPE {
    unknown,
    welcome,
    request_players, // for requesting a certain number of players to be on a client machine
    controller,
    gfx,
    cmd,
    ping,
    skin
}

// response codes
enum RES {
    approved,
    rejected,
    rejected_unauthorized
}

max_ping_id = 32;

// server variables
srv_isServing = false;
srv_isAccepting = false;
srv_maxPlayers = 4; //-1 means indefinite
srv_maxConnections = -1; //-1 means indefinite
srv_port = DEFAULT_PORT;
srv_title = "A Megamix Server";
srv_password = ""
srv_player_count = 0;
srv_p_input_n = 0;

srv_connection_count = 0;
// sockets, IP addresses, and ports of clients -- enough to send them a message.
srv_id_connection_map = ds_map_create();

// client variables
cli_status = 0;
CLI_STATUS_MESSAGES = makeArray("Not Connected", "Joined", "Joining")
cli_host_url = "127.0.0.1";
cli_host_port = DEFAULT_PORT
cli_host_title = ""
cli_host_password = ""
cli_ping[max_ping_id] = 0
cli_ping_systime[max_ping_id] = 0
cli_ping_avg = 0; // average ping recorded
cli_ping_waiting[max_ping_id] = false;
//cli_socket

// common to both client and server
loc_player_count = 0; // number of players playing locally approved by server
loc_player_ids = makeArray(-1); // set by server, not read by server
loc_forwardControl_ids = makeArray(-1); // source for control input (on server, must equal with loc_player_ids)
gx_buff = buffer_create(10000,buffer_grow,1);
cmd_buff = buffer_create(10000,buffer_grow,1);
tile_buff = buffer_create(80000,buffer_grow,1);
tile_buff_chunk_n = 0;

ping_timer = 0;
ping_id = 0;
ping_print_timer = 0;

// example sprites
eg_spr = sprRockman;
eg_bg = bgBeta;

console_log_n = 14;
console_log_show = true;
for (i=0;i&lt;console_log_n;i++) {
    console_log[i] = ""
    console_color[i] = c_white
    console_time[i] = 0;
}

tile_clear_timer = 0;
ncmd_tiles_timer = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (tile_clear_timer &lt; 300)
{
    tile_clear_timer ++;
}

/// send input
if cli_status == 1 { 
    for (j=0; j&lt;loc_player_count; j++) {
        buffer_seek(buff, buffer_seek_start, 0);
        buffer_write(buff, buffer_u8, PTYPE.controller)
        buffer_write(buff, buffer_u16, loc_forwardControl_ids[j]);
        i = loc_player_ids[j];
        controller_data = 0;
        controller_data += global.keyLeft[i]  &lt;&lt;0
        controller_data += global.keyRight[i] &lt;&lt;1
        controller_data += global.keyUp[i]    &lt;&lt;2
        controller_data += global.keyDown[i]  &lt;&lt;3
        controller_data += global.keyShoot[i] &lt;&lt;4
        controller_data += global.keyJump[i]  &lt;&lt;5
        controller_data += global.keySlide[i] &lt;&lt;6
        controller_data += global.keyPause[i] &lt;&lt;7
        controller_data += global.keyWeaponSwitchLeft[i]  &lt;&lt;8
        controller_data += global.keyWeaponSwitchRight[i] &lt;&lt;9
        controller_data += global.keyLeftPressed[i]  &lt;&lt;10
        controller_data += global.keyRightPressed[i] &lt;&lt;11
        controller_data += global.keyUpPressed[i]    &lt;&lt;12
        controller_data += global.keyDownPressed[i]  &lt;&lt;13
        controller_data += global.keyShootPressed[i] &lt;&lt;14
        controller_data += global.keyJumpPressed[i]  &lt;&lt;15
        controller_data += global.keySlidePressed[i] &lt;&lt;16
        controller_data += global.keyPausePressed[i] &lt;&lt;17
        controller_data += global.keyWeaponSwitchLeftPressed[i]  &lt;&lt;18
        controller_data += global.keyWeaponSwitchRightPressed[i] &lt;&lt;19

        buffer_write(buff, buffer_u32, controller_data);
        network_send_udp(cli_socket, objNet.cli_host_url, objNet.cli_host_port, buff, buffer_tell(buff) );
    }
}

if srv_isServing {
    for (i = loc_player_count; i &lt; srv_p_input_n; i++) {
        // held down:
        global.keyLeft[i]  = (srv_p_input[i] &gt;&gt; 0) &amp; $1;
        global.keyRight[i] = (srv_p_input[i] &gt;&gt; 1) &amp; $1;
        global.keyUp[i]    = (srv_p_input[i] &gt;&gt; 2) &amp; $1;
        global.keyDown[i]  = (srv_p_input[i] &gt;&gt; 3) &amp; $1;
        global.keyShoot[i] = (srv_p_input[i] &gt;&gt; 4) &amp; $1;
        global.keyJump[i]  = (srv_p_input[i] &gt;&gt; 5) &amp; $1;
        global.keySlide[i] = (srv_p_input[i] &gt;&gt; 6) &amp; $1;
        global.keyPause[i] = (srv_p_input[i] &gt;&gt; 7) &amp; $1;
        global.keyWeaponSwitchLeft[i]  = (srv_p_input[i] &gt;&gt; 8) &amp; $1;
        global.keyWeaponSwitchRight[i] = (srv_p_input[i] &gt;&gt; 9) &amp; $1;

        // pressed
        global.keyLeftPressed[i]  = (srv_p_input[i] &gt;&gt; 10) &amp; $1;
        global.keyRightPressed[i] = (srv_p_input[i] &gt;&gt; 11) &amp; $1;
        global.keyUpPressed[i]    = (srv_p_input[i] &gt;&gt; 12) &amp; $1;
        global.keyDownPressed[i]  = (srv_p_input[i] &gt;&gt; 13) &amp; $1;
        global.keyShootPressed[i] = (srv_p_input[i] &gt;&gt; 14) &amp; $1;
        global.keyJumpPressed[i]  = (srv_p_input[i] &gt;&gt; 15) &amp; $1;
        global.keySlidePressed[i] = (srv_p_input[i] &gt;&gt; 16) &amp; $1;
        global.keyPausePressed[i] = (srv_p_input[i] &gt;&gt; 17) &amp; $1;
        global.keyWeaponSwitchLeftPressed[i]  = (srv_p_input[i] &gt;&gt; 18) &amp; $1;
        global.keyWeaponSwitchRightPressed[i] = (srv_p_input[i] &gt;&gt; 19) &amp; $1;
        
        // reset for future frames
        srv_p_input[i] &amp;= $1FF;
    }
}

if keyboard_check_pressed(vk_f9) {
    console_log_show ^= true;
    print("Toggled console")
}

for (var i=0;i&lt;console_log_n;i++) {
  if console_time[i] &gt; 0
    console_time[i] -= 1;
  else
    console_log[i] = ""
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>srv_isServing</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>true</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>net_serve_process();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>cli_status</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>2</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>objNet</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/// handle incoming network requests from server

var type = async_load[? "type"]

if type == network_type_data {
    var in_buff = async_load[? "buffer"]
    var in_buff_size = async_load[? "size"]
    buffer_seek(in_buff, buffer_seek_start, 0);
    buffer_seek(buff, buffer_seek_start, 0);
    
    var packet_type = buffer_read(in_buff, buffer_u8);
    switch packet_type {
        case PTYPE.welcome:
            var res = buffer_read(in_buff, buffer_u8);
            if res == RES.approved {
                cli_status = 1;
                cli_host_title = buffer_read(in_buff, buffer_string)
                print("Connected to " + cli_host_title, c_green)
            } else {
                cli_status = 0;
                print("Failed to connect to " + cli_status, c_red)
            }
            break;
        case PTYPE.request_players:
            print("Player count request processed:")
            var res = buffer_read(in_buff, buffer_u8);
            if res == RES.approved {
                if !cli_authorized
                    print("Authorization received.", c_green)
                loc_player_ids[loc_player_count] = loc_player_count;
                loc_forwardControl_ids[loc_player_count] = buffer_read(in_buff, buffer_u16)
                loc_player_count += 1;
                cli_authorized = true;
                room_goto(rmNetClient);
            } else if res == RES.rejected_unauthorized {
                cli_authorized = false;
                print("Server refused to authorize us.", c_red)
            }
            break;
        case PTYPE.gfx:
            var bsize = buffer_get_size(in_buff);
            buffer_copy(in_buff, buffer_tell(in_buff), bsize - buffer_tell(in_buff), gx_buff, 0);
            buffer_seek(gx_buff, buffer_seek_start, bsize)
            break;
        case PTYPE.cmd:
            while(cli_perform_cmd_buff(in_buff)) {}
            break;
        case PTYPE.ping:
            // add ping time to array:
            var in_ping_id = buffer_read(in_buff, buffer_u8);
            if in_ping_id &lt; max_ping_id {
                if cli_ping_systime[in_ping_id] &gt; 0 {
                    cli_ping[in_ping_id] = current_time - cli_ping_systime[in_ping_id];
                    cli_ping_waiting[in_ping_id] = false;
                    // calculate average ping:
                    cli_ping_avg = 0;
                    for (var i=0;i&lt; max_ping_id; i++) {
                        cli_ping_avg += cli_ping[i];
                    }
                    cli_ping_avg /= 2*max_ping_id;
                }
            }
            break;
    }
    // respond
    if buffer_tell(buff) &gt; 0
        network_send_udp(cli_socket, cli_host_ip, cli_host_port, buff, buffer_tell(buff));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ncmd_tiles();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if view_current != 0
    exit;

max_udp_package_size = 8100;
    
if srv_isServing {
    ncmd_tiles_timer -= 1;
    if ncmd_tiles_timer == 0 {
        ncmd_tiles();
    }
    
    // send a single tile buffer chunk
    if tile_buff_chunk_n &gt; 0 {
        var bsize = tile_buff_chunk[1] - tile_buff_chunk[0];
        buffer_copy(tile_buff, tile_buff_chunk[0], bsize, cmd_buff, buffer_tell(cmd_buff));
        buffer_seek(cmd_buff, buffer_seek_relative, bsize);
        
        // adjust indices so that later the next chunk will be sent:
        for (var i=0;i &lt; tile_buff_chunk_n; i++) {
            tile_buff_chunk[i] = tile_buff_chunk[i+1]
        }
    }

    srv_flush_buffers();
}

if cli_status == 1 {
    // draw gx buffer
    buffer_seek(gx_buff,buffer_seek_start,0);
    while (cli_draw_gx_buff(gx_buff)) {};
    
    // ping:
    // this could probably be moved to the step event
    ping_timer += 1
    ping_print_timer += 1;
    if ping_print_timer &gt;= 1000 {
      ping_print_timer = 0;
      pcol = c_gray;
      if cli_ping_avg &gt; 20
          pcol = make_color_rgb(128,128,40)
      if cli_ping_avg &gt; 50
          pcol = make_color_rgb(180,60,40)
      if cli_ping_avg &gt; 100
          pcol = make_color_rgb(200,40,40)
      if cli_ping_avg &gt; 200
          pcol = make_color_rgb(256,20,20)
      if cli_ping_avg &gt; 300
          pcol = make_color_rgb(256,0,0)
      print("Ping: " + string_format(cli_ping_avg,7,2) + " ms", pcol)
    }
    if ping_timer &gt;= 10 &amp;&amp;! cli_ping_waiting[ping_id] {
        ping_timer  = 0;
        cli_ping_systime[ping_id] = current_time;
        
        buffer_seek(buff, buffer_u8, 0);
        buffer_write(buff, buffer_u8, PTYPE.ping);
        buffer_write(buff, buffer_u8, ping_id);
        network_send_udp(cli_socket, cli_host_url, cli_host_port, buff, buffer_tell(buff));
        cli_ping_waiting[ping_id] = true;
        
        ping_id = (ping_id + 1) mod max_ping_id;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
